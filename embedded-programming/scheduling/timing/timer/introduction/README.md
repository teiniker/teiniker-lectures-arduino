# Timer 

Timers are **hardware peripherals** inside the ATmega328P microcontroller 
that **count clock pulses** automatically. They let the microcontroller 
measure time, generate precise delays, create PWM signals, and trigger 
actions at exact intervals without constantly using the CPU.

A timer is essentially a **register that increments (counts up) or 
decrements** at a fixed rate derived from the system clock (16 MHz on 
Arduino Uno).

The Arduino Uno uses the **ATmega328P** microcontroller, which has 
three timers:

* **Timer0 (8-bit)**: Used by `millis()`, `micros()`, `delay()`

* **Timer1 (16-bit)**: Not used by Arduino (used by TimerOne)

* **Timer2 (8-bit)**: Used by `tone()`

TimerOne exclusively controls Timer1, which means:
* It does not interfere with `millis()` or `delay()`
* It does override default PWM behavior on certain pins


## Interrupts 

An **interrupt** is a mechanism that allows a microcontroller to 
temporarily **stop executing its main program** when an important 
event occurs and **immediately respond to that event**.

Instead of continuously checking (polling) for events, the CPU 
is notified automatically.

> Idea: Stop what you’re doing, handle this urgent task, then continue.

There are different **interrupt types** in Arduino:
* **External Interrupts**: Triggered by pin changes (e.g., button press)
* **Pin Change Interrupts**: Triggered when any pin in a group changes
* **Timer Interrupts**: Triggered by hardware timers.
    A timer interrupt is an interrupt generated by a hardware timer 
    when it reaches a specific condition such as timer overflow or 
    compare match.


### Interrupt Service Routine (ISR)

An ISR is a **special function that runs automatically when an 
interrupt occurs**.

* It is not called manually.
* It runs immediately after the interrupt.
* After finishing, the CPU returns to the main program

Program flow with interrupt:
1. Main program runs
2. Interrupt occurs
3. CPU jumps to ISR
4. ISR executes
5. CPU resumes main program

**Implementing an ISR** is powerful, but it comes with strict rules 
and important considerations. Following these is crucial to ensure 
correct, reliable, and efficient system behavior, especially on 
platforms like Arduino Uno (ATmega328P).

* **Keep the ISR Short and Fast**: ISRs should do only the minimum 
    required work.

    _Good practice_: Set a flag, increment a counter, capture a timestamp

    _Bad practice_: Long loops,complex calculations, waiting for events


* **Never Use Blocking Functions**: Avoid functions that depend on 
    interrupts or timing. 

    _Good practice_: Simple variable updates, Hardware registers

    _Bad practice_: `delay()`, `delayMicroseconds()`, `Serial.print()`, 
        `millis()` / `micros()`

* **Use volatile for Shared Variables**: Variables modified inside an ISR and 
    used in `loop()` must be declared `volatile`.
    This prevents the compiler from optimizing away critical reads/writes.

    _Example:_ `volatile bool timerFlag = false;`

* **Avoid Calling Other ISRs or Nested Interrupts**: Most Arduino ISRs run with 
    global interrupts disabled.
    - No nested interrupts
    - No function calls that rely on interrupts

    This avoids priority conflicts and timing errors.

* **Protect Multi-Byte Shared Data**: On 8-bit microcontrollers, multi-byte 
    variables are not updated atomically.

    _Good practice_: Temporarily disable interrupts

* **Use Flags to Communicate with loop()**:

    _Example:_

    ```C++
    volatile bool eventFlag = false;

    ISR(TIMER1_COMPA_vect) 
    {
        eventFlag = true;
    }

    void loop() 
    {
        if (eventFlag) 
        {
            eventFlag = false;
            // Handle event here
        }
    }    
    ```
* Do Not Allocate Memory Inside ISR: Dynamic memory allocation is 
    slow and unsafe inside ISRs.

    _Bad practice_: `malloc()`, `new`, `String` objects


## References

* [DroneBot Workshop: Using Arduino Interrupts – Hardware, Pin Change and Timer](https://dronebotworkshop.com/interrupts/)

_Egon Teiniker, 2020-2025, GPL v3.0_